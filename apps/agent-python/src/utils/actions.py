from typing import Dict, List, Any
from langchain_core.messages import AIMessage
from ..types import State, ActionItem, ActionType
from ..services.database import TaskService, LogService, ChatMessageService


async def execute_actions(state: State, actions: List[ActionItem]) -> Dict[str, Any]:
    """
    Execute actions generated by the agents.

    Args:
        state: Current state
        actions: List of actions to execute

    Returns:
        Dictionary of state updates
    """
    updates = {}

    for action in actions:
        try:
            if action.type == ActionType.CREATE_TASK:
                new_task = await TaskService.create_task({
                    **action.payload,
                    'userId': state.userId
                })
                updates['task'] = new_task

            elif action.type == ActionType.UPDATE_TASK:
                if state.task and state.task.id:
                    updated_task = await TaskService.update_task({
                        'id': state.task.id,
                        'userId': state.userId,
                        **action.payload
                    })
                    updates['task'] = updated_task

            elif action.type == ActionType.CREATE_SUBTASKS:
                if state.task and state.task.id:
                    await TaskService.create_subtasks(
                        state.task.id,
                        state.userId,
                        action.payload.get('subtasks', [])
                    )
                    # Refresh the task to include new subtasks
                    refreshed_task = await TaskService.get_task(state.task.id, state.userId)
                    if refreshed_task:
                        updates['task'] = refreshed_task

            elif action.type == ActionType.SEARCH_TASKS:
                search_results = await TaskService.get_tasks(state.userId, action.payload)
                updates['tasks'] = search_results

            elif action.type == ActionType.UPDATE_MANY_TASKS:
                await TaskService.update_many_tasks(action.payload)
                # Refresh tasks if we have them loaded
                if state.tasks and len(state.tasks) > 0:
                    updates['tasks'] = await TaskService.get_tasks(state.userId)

            elif action.type == ActionType.LOG_ACTIVITY:
                await LogService.create_log({
                    **action.payload,
                    'userId': state.userId,
                    'author': 'Model'
                })

            elif action.type == ActionType.SCHEDULE_REMINDER:
                if state.task and state.task.id:
                    await TaskService.update_task({
                        'id': state.task.id,
                        'userId': state.userId,
                        'notifications': {
                            'create': [action.payload]
                        }
                    })

            elif action.type in [ActionType.PROVIDE_MOTIVATION, ActionType.GIVE_ADVICE, ActionType.ASK_QUESTION]:
                # These are handled by adding messages to the state
                if action.payload and action.payload.get('content'):
                    if 'messages' not in updates:
                        updates['messages'] = []
                    updates['messages'].append(AIMessage(
                        content=action.payload['content'],
                        name=action.type.value
                    ))

                    # Also store in database if needed
                    await ChatMessageService.create_message({
                        'userId': state.userId,
                        'taskId': state.task.id if state.task else None,
                        'content': action.payload['content'],
                        'role': 'assistant',
                        'metadata': {'actionType': action.type.value}
                    })

        except Exception as error:
            print(f"Error executing action {action.type}: {error}")
            updates['error'] = f"Failed to execute {action.type}: {error}"

    return updates
