import { Task, Prisma, ChatMessageRole } from '@prisma/client'
import { prisma } from '@/lib/prisma'
import { LogService } from './logService'
import type { TaskPriority, TaskStage } from '@/types/task'
import { ChatCompletionSystemMessageParam, ChatCompletionUserMessageParam } from 'openai/resources/index.mjs'
import OpenAI from 'openai'
import { Tag } from '@/types/tag'
import { TagService } from './tagService'
import { ChatMessageService } from './chatMessageService'

// Notification enum types from Prisma schema
type NotificationType = 'Reminder' | 'Question' | 'Info'
type NotificationMode = 'Push' | 'Email' | 'Chat'
type NotificationTrigger = 'FixedTime' | 'RelativeTime' | 'Location'
type NotificationRelativeTimeUnit = 'Minutes' | 'Hours' | 'Days'
type NotificationAuthor = 'User' | 'Bot' | 'Model'

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})

export interface TaskRefinedData {
  title: string;
  description: string;
  priority: string;
  deadline: string;
  estimatedTimeMinutes: number;
  why: string;
  location: string
  tags: { name: string, category: string }[];
}

// Interface for a single sub-task generated by the breakdown AI
export interface TaskBreakdownSubTask {
  title: string;
  description?: string;
  estimatedTimeMinutes?: number;
}

// Interface for the AI response containing sub-tasks
export interface TaskBreakdownData {
  replace: boolean;
  sub_tasks: TaskBreakdownSubTask[];
}

export interface NotificationCreateinput {
  mode: NotificationMode;
  type: NotificationType;
  trigger?: NotificationTrigger;
  message: string;
  relativeTimeValue?: number;
  relativeTimeUnit?: NotificationRelativeTimeUnit;
  fixedTime?: Date;
  author: NotificationAuthor;
}

export interface ChildrenCreateinput {
  title: string;
  description?: string;
}

export interface ChildrenUpdateInput {
  id: string;
  title: string;
  description?: string;
}

export interface CreateTaskInput {
  userId: string;
  title: string;
  description?: string;
  date: Date;
  time?: string;
  deadline?: Date;
  priority?: TaskPriority;
  stage?: "Refinement" | "Breakdown" | "Planning" | "Execution" | "Reflection";
  estimatedTimeMinutes?: number;
  location?: string;
  why?: string;
  parentId?: string;
  tagIds?: string[];
  children?: {
    title: string;
    priority?: string;
    stage?: string;
  }[];
  notifications?: NotificationCreateinput[];
}

export interface NotificationUpdateInput {
  id: string;
  mode?: NotificationMode;
  type?: NotificationType;
  trigger?: NotificationTrigger;
  message?: string;
  relativeTimeValue?: number;
  relativeTimeUnit?: NotificationRelativeTimeUnit;
  fixedTime?: Date;
  author?: NotificationAuthor;
}

export interface UpdateTaskInput {
  id: string;
  userId: string;
  title?: string;
  description?: string;
  date?: Date;
  time?: string;
  deadline?: Date;
  priority?: TaskPriority;
  stage?: "Refinement" | "Breakdown" | "Planning" | "Execution" | "Reflection";
  stageStatus?: "NotStarted" | "InProgress" | "QuestionAsked" | "Completed";
  estimatedTimeMinutes?: number;
  location?: string;
  repeats?: string;
  why?: string;
  tagIds?: string[];
  completed?: boolean,
  children?: {
    create: ChildrenCreateinput[],
    update: ChildrenUpdateInput[],
    removeIds: string[],
  }
  notifications?: {
    create: NotificationCreateinput[],
    update: NotificationUpdateInput[],
    removeIds: string[],
  }
}

export interface ProcessTaskInput {
  id: string;
  userId: string;
  nextStage?: TaskStage
}

export interface ProcessTaskResponse {
  response_type: "message_to_user" | "task_details";
  task: Task | null;
  message: string;
}

export class TaskService {
  static async createTask(input: CreateTaskInput): Promise<Task> {
    const { userId, children, tagIds, notifications, parentId, ...taskData } = input

    // Create the task with its children (subtasks) and tags first
    const newTask = await prisma.task.create({
      data: {
        ...taskData,
        user: { connect: { id: userId } },
        parent: parentId ? {
          connect: {
            id: parentId,
          }
        }: undefined,
        children: children ? {
          create: children.map(child => ({
            ...child,
            userId: userId,
            date: taskData.date,
            priority: taskData.priority,
            stage: taskData.stage
          }))
        } : undefined,
        notifications: notifications ? {
          create: notifications.map(notification => ({
            message: notification.message,
            mode: notification.mode,
            type: notification.type,
            trigger: notification.trigger || 'RelativeTime',
            relativeTimeValue: notification.relativeTimeValue,
            relativeTimeUnit: notification.relativeTimeUnit,
            fixedTime: notification.fixedTime,
            author: notification.author,
            userId: userId,
            // taskId: newTask.id
          })),
        } : undefined,
        tags: tagIds && tagIds.length > 0 ? {
          connect: tagIds.map(id => ({ id }))
        } : undefined
      },
      include: {
        children: true,
        tags: {
          include: {
            category: true
          }
        },
        notifications: true
      }
    })

    // Create a log entry for the new task
    LogService.createTaskLog({
      type: 'task_created',
      userId,
      taskId: newTask.id,
      data: {
        title: newTask.title,
        date: newTask.date,
        priority: newTask.priority,
        childrenCount: children?.length || 0,
        notificationsCount: notifications?.length || 0
      }
    })

    return newTask;
  }

  static async updateTask(input: UpdateTaskInput): Promise<Task> {
    const { id, userId, children, tagIds, notifications, ...updates } = input

    // Update the task and create a log entry
    const task = await prisma.$transaction(async (tx) => {
      // If tagIds are provided, first disconnect all existing tags
      if (tagIds !== undefined) {
        await tx.task.update({
          where: {
            id,
            userId
          },
          data: {
            tags: {
              set: []
            }
          }
        });
      }


      const updatedTask = await tx.task.update({
        where: {
          id,
          userId
        },
        data: {
          ...updates,
          children: children ? {
            create: children?.create?.map(child => ({
              ...child,
              userId: userId,
              date: updates.date || new Date(),
            })),
            update: children?.update?.map(child => ({
              where: {
                id: child.id,
              },
              data: {
                ...child,
                userId: userId,
                date: updates.date || new Date(),
              },
            })),
            deleteMany: children?.removeIds.map(id => ({ id })),
          } : undefined,
          tags: tagIds && tagIds.length > 0 ? {
            connect: tagIds.map(id => ({ id }))
          } : undefined,
          notifications: {
            create: notifications?.create?.map(notification => ({
              ...notification,
              userId: userId,
            })),
            update: notifications?.update?.map(notification => ({
              where: {
                id: notification.id,
              },
              data: {
                ...notification,
              }
            })),
            deleteMany: notifications?.removeIds.map(id => ({ id })),
          }
        },
        include: {
          children: true,
          tags: {
            include: {
              category: true
            }
          },
          notifications: true
        }
      })

      // Create a log entry for the task update
      await LogService.createTaskLog({
        type: 'task_updated',
        userId,
        taskId: id,
        data: {
          updatedFields: Object.keys(updates),
          newValues: updates,
          childrenAdded: children?.create?.length || 0,
          notificationsUpdated: notifications?.create?.length || 0
        }
      })

      return updatedTask
    })

    return task
  }

  static async deleteTask(id: string, userId: string): Promise<void> {
    // Get task details before deletion for logging
    const task = await prisma.task.findUnique({
      where: { id },
      select: { title: true }
    })

    // Delete the task and create a log entry
    await prisma.$transaction(async (tx) => {
      await tx.task.delete({
        where: {
          id,
          userId
        }
      })

      // Create a log entry for the task deletion
      await LogService.createTaskLog({
        type: 'task_deleted',
        userId,
        taskId: id,
        data: {
          title: task?.title
        }
      })

    })
  }

  static async processTask(input: ProcessTaskInput): Promise<ProcessTaskResponse> {
    const { id, userId, nextStage } = input

    // Fetch the original task with all its details
    const originalTask = await TaskService.getTask(id, userId)

    if (!originalTask) {
      return {
        response_type: "message_to_user",
        task: null,
        message: "Task not found"
      };
    }

    const taskStage = nextStage || originalTask.stage;
    const taskStageStatus = nextStage ? 'NotStarted' : originalTask.stageStatus;

    if (taskStage === 'Planning' || taskStage === 'Refinement') {
      if (taskStageStatus === 'NotStarted' || taskStageStatus === 'InProgress') {
        console.log('startRefinement');
        const result = await TaskService.startRefinement(originalTask);
        return result;
      }

      if (taskStageStatus === 'QuestionAsked' || taskStageStatus === 'Completed') {
        console.log('continueRefinement');
        const result = await TaskService.continueRefinement(originalTask);
        return result;
      }
    }

    // If refinement is done, start breakdown
    if (taskStage === 'Refinement' && taskStageStatus === 'Completed') {
      console.log('startBreakdown');
      const result = await TaskService.startBreakdown(originalTask);
      return result;
    }

    // If already in breakdown stage, continue
    if (taskStage === 'Breakdown') {
      if (taskStageStatus === 'NotStarted' || taskStageStatus === 'InProgress') {
        console.log('startBreakdown (continuing existing)'); // Or restart if needed?
        const result = await TaskService.startBreakdown(originalTask);
        return result;
      }
      if (taskStageStatus === 'QuestionAsked' || taskStageStatus === 'Completed') {
        // Completed might mean we need to check if user wants further breakdown or move to execution
        // For now, assume Completed means ready for execution, or continue if QuestionAsked
        console.log('continueBreakdown');
        const result = await TaskService.continueBreakdown(originalTask);
        return result;
      }
    }

    return {
      response_type: "message_to_user",
      task: originalTask,
      message: "No processing needed for current task stage"
    };
  }

  static async getTasks(userId: string): Promise<Task[]> {
    return prisma.task.findMany({
      where: {
        userId,
      },
      include: {
        children: true,
        tags: {
          include: {
            category: true
          }
        },
        notifications: true
      },
      orderBy: { dateAdded: 'desc' }
    })
  }

  static async getTask(id: string, userId: string): Promise<Task | null> {
    return prisma.task.findFirst({
      where: {
        id,
        userId
      },
      include: {
        children: true,
        tags: {
          include: {
            category: true
          }
        },
        notifications: true
      }
    })
  }

  static async completeTask(id: string, userId: string): Promise<Task> {
    const task = await prisma.$transaction(async (tx) => {
      const updatedTask = await tx.task.update({
        where: {
          id,
          userId
        },
        data: {
          completed: true,
        },
        include: {
          children: true,
          notifications: true
        }
      })

      // Create a log entry for task completion
      await LogService.createTaskLog({
        type: 'task_completed',
        userId,
        taskId: id,
        data: {
          title: updatedTask.title,
          completedAt: new Date()
        }
      })

      return updatedTask
    })

    return task
  }

  static async reactivateTask(id: string, userId: string): Promise<Task> {
    const task = await prisma.$transaction(async (tx) => {
      const updatedTask = await tx.task.update({
        where: {
          id,
          userId
        },
        data: {
          completed: false,
        },
        include: {
          children: true,
          notifications: true
        }
      })

      // Create a log entry for task reactivation
      await LogService.createTaskLog({
        type: 'task_reactivated',
        userId,
        taskId: id,
        data: {
          title: updatedTask.title,
          reactivatedAt: new Date()
        }
      })

      return updatedTask
    })

    return task
  }

  static async startRefinement(task: Task): Promise<ProcessTaskResponse> {
    // Update the task status
    const updatedTask = await TaskService.updateTask({
      id: task.id,
      userId: task.userId,
      stage: 'Refinement',
      stageStatus: 'InProgress',
    });

    // Prepare task data for OpenAI
    const taskForAI = {
      id: task.id,
      title: task.title,
      description: task.description || '',
      priority: task.priority,
      stage: task.stage,
      deadline: task.deadline,
      estimatedTimeMinutes: task.estimatedTimeMinutes,
      location: task.location || '',
      why: task.why || '',
      tags: Array.isArray((task as any).tags)
        ? (task as any).tags.map((tag: Tag) => ({
          name: tag.name,
          category: tag.category?.name || ''
        }))
        : []
    }

    const refineTaskInstructionMessages: Array<ChatCompletionUserMessageParam | ChatCompletionSystemMessageParam> = [
      {
        role: "system",
        content: `You are a task optimization assistant.
          Your job is to improve task descriptions, suggest appropriate tags, refine deadlines, and estimate time better.
          Start by understanding the task, if you less than 90% sure about the task, ask a question to the user.
          Provide output in JSON format only with these fields: response_type (must be 'task_details', 'question'), question (if response_type=question), understand_percentage (if response_type=question), task_details (if response_type=task_details, nested fields: title, description, priority (must be 'low', 'medium', or 'high'), deadline (ISO string or null), estimatedTimeMinutes (number), location (string), why (string), tags (max 2, object with fields name (string) and category (string))).
        `
      },
      {
        role: "user",
        content: `Please refine this task by providing a more detailed description, better tags, and more accurate time estimates and deadlines if needed:\n${JSON.stringify(taskForAI, null, 2)}`
      }
    ];

    const createdMessages = await prisma.chatMessage.createMany({
      data: refineTaskInstructionMessages.map(({ role, content }) => ({
        role: role as ChatMessageRole,
        content: content as string,
        userId: task.userId,
        taskId: task.id,
      }))
    })

    // Send data to OpenAI for refinement
    const aiResponse = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: refineTaskInstructionMessages,
      response_format: { type: "json_object" }
    })

    // Parse the AI response
    const responseData = JSON.parse(aiResponse.choices[0].message.content || '{}')
    console.log('AI response', responseData);

    if (responseData.response_type === 'question') {
      // Save the question directly using prisma
      const storedMessage = await prisma.chatMessage.create({
        data: {
          userId: task.userId,
          taskId: task.id,
          content: responseData.question,
          role: 'assistant',
          metadata: {
            understand_percentage: responseData.understand_percentage || 0,
            type: "question"
          }
        }
      })

      // Update the task status
      const updatedTask = await TaskService.updateTask({
        id: task.id,
        userId: task.userId,
        stageStatus: 'QuestionAsked',
      });

      return {
        response_type: "message_to_user",
        task: updatedTask,
        message: responseData.question
      };
    }

    const refinedData = responseData.task_details;
    const updatedTaskWithRefinements = await TaskService.updateRefinedTask(task, refinedData);

    return {
      response_type: "task_details",
      task: updatedTaskWithRefinements,
      message: "Task has been successfully refined with AI assistance."
    };
  }

  static async continueRefinement(task: Task): Promise<ProcessTaskResponse> {
    const storedMessages = await ChatMessageService.getMessages(task.id);
    const latestMessage = storedMessages[storedMessages.length - 1];
    console.log('latest message', latestMessage);
    
    if (latestMessage && latestMessage.role === 'user') {
      // Send data to OpenAI for refinement
      const aiResponse = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: storedMessages,
        response_format: { type: "json_object" }
      })

      // Parse the AI response
      const responseData = JSON.parse(aiResponse.choices[0].message.content || '{}')
      console.log('AI response', responseData);

      if (responseData.response_type === 'question') {
        // Save the question directly using prisma
        const storedMessage = await prisma.chatMessage.create({
          data: {
            userId: task.userId,
            taskId: task.id,
            content: responseData.question,
            role: 'assistant',
            metadata: {
              understand_percentage: responseData.understand_percentage || 0,
              type: "question"
            }
          }
        })

        return {
          response_type: "message_to_user",
          task: task,
          message: responseData.question
        };
      }

      const refinedData = responseData.task_details;
      const updatedTask = await TaskService.updateRefinedTask(task, refinedData);

      return {
        response_type: "task_details",
        task: updatedTask,
        message: "Task has been successfully refined with AI assistance."
      };
    }

    return {
      response_type: "message_to_user",
      task: task,
      message: "No user message found to continue refinement."
    };
  }

  static async updateRefinedTask(task: Task, refinedData: TaskRefinedData): Promise<Task> {
    // Prepare the update data with proper type validation
    const updates: UpdateTaskInput = {
      id: task.id,
      userId: task.userId,
      title: refinedData.title,
      description: refinedData.description,
      priority: ['low', 'medium', 'high'].includes(refinedData.priority?.toLowerCase())
        ? refinedData.priority.toLowerCase() as TaskPriority
        : undefined,
      deadline: refinedData.deadline ? new Date(refinedData.deadline) : undefined,
      estimatedTimeMinutes: typeof refinedData.estimatedTimeMinutes === 'number'
        ? refinedData.estimatedTimeMinutes
        : undefined,
      why: refinedData.why,
      location: refinedData.location,
      stageStatus: 'Completed',
    }

    // Handle tags from AI response
    if (refinedData.tags && Array.isArray(refinedData.tags)) {
      const [allTags, allCategories] = await Promise.all([
        TagService.getTags(),
        TagService.getTagCategories()
      ])

      const tagIds: string[] = []

      for (const tagData of refinedData.tags) {
        let existingTag = allTags.find((t) => t.name.toLowerCase() === tagData.name.toLowerCase())

        if (!existingTag) {
          console.log('creating tag', tagData);
          let categoryId: string | undefined

          if (tagData.category) {
            let category = allCategories.find((c) => c.name.toLowerCase() === tagData.category.toLowerCase())

            if (!category) {
              console.log('creating category', tagData);
              category = await TagService.createTagCategory({ name: tagData.category })
              allCategories.push(category)
            }

            categoryId = category.id
          }

          existingTag = await TagService.createTag({
            name: tagData.name,
            color: '#808080',
            categoryId
          })
          allTags.push(existingTag)
        }

        tagIds.push(existingTag.id)
      }

      updates.tagIds = tagIds
    }

    const updatedTask = await TaskService.updateTask(updates)

    if (updatedTask) {
      await prisma.chatMessage.create({
        data: {
          userId: task.userId,
          taskId: task.id,
          content: "Task has been successfully refined with AI assistance.",
          role: ChatMessageRole.system,
          metadata: {
            type: "info",
            refinement: true
          }
        }
      })
    }

    return updatedTask;
  }

  static async startBreakdown(task: Task): Promise<ProcessTaskResponse> {
    // Update the task status
    const updatedTask = await TaskService.updateTask({
      id: task.id,
      userId: task.userId,
      stage: 'Breakdown',
      stageStatus: 'InProgress',
    });

    // Prepare task data for OpenAI (similar to refinement)
    const taskForAI = {
      id: task.id,
      title: task.title,
      description: task.description || '',
      priority: task.priority,
      deadline: task.deadline,
      estimatedTimeMinutes: task.estimatedTimeMinutes,
      location: task.location || '',
      why: task.why || '',
      tags: Array.isArray((task as any).tags)
        ? (task as any).tags.map((tag: Tag) => ({
          name: tag.name,
          category: tag.category?.name || ''
        }))
        : []
    }

    const breakdownTaskInstructionMessages: Array<ChatCompletionUserMessageParam | ChatCompletionSystemMessageParam> = [
      {
        role: "system",
        content: `You are a task breakdown assistant.
          Your job is to break down a given task into smaller, actionable sub-tasks.
          Aim for sub-tasks that can be completed in roughly 10-15 minutes each (the '10-minute task' strategy), but be flexible based on the task complexity.
          If the task seems too complex or ambiguous to break down effectively, ask a clarifying question to the user.
          Provide output in JSON format only with these fields: response_type (must be 'sub_tasks', 'question'), replace (must be boolean, this tells is existing subtasks are removed or not), question (if response_type=question), sub_tasks (if response_type=sub_tasks, it must be an array of objects, each object having fields: title (string, required), description (string, optional), estimatedTimeMinutes (number, optional, default to 10 if not specified)).
          Example sub_tasks array: [{ "title": "Draft initial email", "estimatedTimeMinutes": 10 }, { "title": "Find recipient contact info", "description": "Check CRM and LinkedIn", "estimatedTimeMinutes": 5 }]
        `
      },
      {
        role: "user",
        content: `Please break down this task into smaller sub-tasks using the 10-minute strategy where appropriate:\n${JSON.stringify(taskForAI, null, 2)}`
      }
    ];

    // Save initial system/user messages for context if needed, similar to refinement
    await prisma.chatMessage.createMany({
      data: breakdownTaskInstructionMessages.map(({ role, content }) => ({
        role: role as ChatMessageRole,
        content: content as string,
        userId: task.userId,
        taskId: task.id,
      }))
    });

    // Send data to OpenAI for breakdown
    const aiResponse = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: breakdownTaskInstructionMessages,
      response_format: { type: "json_object" }
    })

    // Parse the AI response
    const responseData = JSON.parse(aiResponse.choices[0].message.content || '{}')
    console.log('AI breakdown response', responseData);

    if (responseData.response_type === 'question') {
      // Save the question
      await prisma.chatMessage.create({
        data: {
          userId: task.userId,
          taskId: task.id,
          content: responseData.question,
          role: 'assistant',
          metadata: {
            type: "question",
            stage: "Breakdown" // Add stage context
          }
        }
      })

      // Update the task status
      const taskAfterQuestion = await TaskService.updateTask({
        id: task.id,
        userId: task.userId,
        stageStatus: 'QuestionAsked',
      });

      return {
        response_type: "message_to_user",
        task: taskAfterQuestion,
        message: responseData.question
      };
    }

    // Assuming response_type is 'sub_tasks'
    const breakdownData = responseData as TaskBreakdownData;
    const updatedTaskWithSubtasks = await TaskService.updateBreakdownTask(task, breakdownData);

    return {
      response_type: "task_details",
      task: updatedTaskWithSubtasks,
      message: "Task has been successfully broken down into sub-tasks."
    };
  }

  static async continueBreakdown(task: Task): Promise<ProcessTaskResponse> {
    const storedMessages = await ChatMessageService.getMessages(task.id);
    const latestMessage = storedMessages[storedMessages.length - 1];
    console.log('latest message for breakdown', latestMessage);

    // Ensure the last message is from the user to continue processing
    if (latestMessage && latestMessage.role === 'user') {
      // Add the system prompt again for context in the continuation?
      // Or assume the context is sufficient from history.
      // For simplicity, let's send the whole history.

      // Send data to OpenAI for refinement
      const aiResponse = await openai.chat.completions.create({
        model: "gpt-4o",
        // Provide the full message history
        messages: storedMessages.map(msg => ({ role: msg.role, content: msg.content })) as Array<ChatCompletionUserMessageParam | ChatCompletionSystemMessageParam>,
        response_format: { type: "json_object" }
      })

      // Parse the AI response
      const responseData = JSON.parse(aiResponse.choices[0].message.content || '{}')
      console.log('AI continue breakdown response', responseData);

      if (responseData.response_type === 'question') {
        // Save the question
        await prisma.chatMessage.create({
          data: {
            userId: task.userId,
            taskId: task.id,
            content: responseData.question,
            role: 'assistant',
            metadata: {
              type: "question",
              stage: "Breakdown"
            }
          }
        })
        // Task status remains QuestionAsked
        return {
          response_type: "message_to_user",
          task: task, // Return original task, status is still QuestionAsked
          message: responseData.question
        };
      }

      // Assuming response_type is 'sub_tasks'
      const breakdownData = responseData as TaskBreakdownData;
      const updatedTaskWithSubtasks = await TaskService.updateBreakdownTask(task, breakdownData);

      return {
        response_type: "task_details",
        task: updatedTaskWithSubtasks,
        message: "Task has been successfully broken down with further information."
      };
    }

    // If last message wasn't from user, or no messages, can't continue automatically
    return {
      response_type: "message_to_user",
      task: task,
      message: "Cannot continue breakdown without a user response to the last question."
    };
  }

  static async updateBreakdownTask(task: Task, breakdownData: TaskBreakdownData): Promise<Task> {
    // Fetch the task with its current children to get their IDs if replacement is needed
    const taskWithChildren = await prisma.task.findUnique({
      where: { id: task.id },
      include: { children: { select: { id: true } } } // Only select children IDs
    });
    const existingChildrenIds = taskWithChildren?.children.map(c => c.id) || [];

    // Validate sub_tasks data
    if (!breakdownData || !Array.isArray(breakdownData.sub_tasks) || breakdownData.sub_tasks.length === 0) {
      console.error("Invalid or empty sub_tasks data received from AI.", breakdownData);
      // Potentially update task status to an error state or ask another question?
      // For now, return the task unchanged but maybe update status to completed to avoid loop.
       await TaskService.updateTask({
         id: task.id,
         userId: task.userId,
         stage: 'Breakdown',
         stageStatus: 'Completed' // Mark as completed even if no subs created
       });
       return task; // Or throw error?
    }

    // Prepare the update data to add children
    const updates: UpdateTaskInput = {
      id: task.id,
      userId: task.userId,
      stage: 'Breakdown',
      stageStatus: 'Completed',
      children: {
        create: breakdownData.sub_tasks.map(sub => ({
          title: sub.title,
          description: sub.description,
          estimatedTimeMinutes: sub.estimatedTimeMinutes || 10, // Default to 10 mins
          // Inherit necessary fields from parent
          userId: task.userId,
          date: task.date, // Assign same date as parent initially
          priority: task.priority, // Assign same priority as parent initially
          stage: 'Execution' // Sub-tasks start in Execution stage
        })),
        update: [],
        removeIds: breakdownData.replace ? existingChildrenIds : [],
      }
    };

    // Perform the update
    const updatedTask = await TaskService.updateTask(updates);

    // Add a system message confirming breakdown
    if (updatedTask) {
      await prisma.chatMessage.create({
        data: {
          userId: task.userId,
          taskId: task.id,
          content: `Task successfully broken down into ${breakdownData.sub_tasks.length} sub-tasks.`, // Corrected template literal
          role: ChatMessageRole.system,
          metadata: {
            type: "info",
            breakdown: true,
            subTaskCount: breakdownData.sub_tasks.length
          }
        }
      });
    }

    return updatedTask;
  }
} 