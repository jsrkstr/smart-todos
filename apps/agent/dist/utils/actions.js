"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeActions = void 0;
const types_1 = require("../types");
const database_1 = require("../services/database");
const messages_1 = require("@langchain/core/messages");
// Execute actions generated by the agents
const executeActions = async (state, actions) => {
    var _a, _b, _c, _d;
    const newState = Object.assign({}, state);
    for (const action of actions) {
        try {
            switch (action.type) {
                case types_1.ActionType.CreateTask:
                    const newTask = await database_1.TaskService.createTask(Object.assign(Object.assign({}, action.payload), { userId: state.userId }));
                    newState.task = newTask;
                    break;
                case types_1.ActionType.UpdateTask:
                    if ((_a = state.task) === null || _a === void 0 ? void 0 : _a.id) {
                        const updatedTask = await database_1.TaskService.updateTask(Object.assign({ id: state.task.id, userId: state.userId }, action.payload));
                        newState.task = updatedTask;
                    }
                    break;
                case types_1.ActionType.CreateSubtasks:
                    if ((_b = state.task) === null || _b === void 0 ? void 0 : _b.id) {
                        await database_1.TaskService.createSubtasks(state.task.id, state.userId, action.payload.subtasks);
                        // Refresh the task to include the new subtasks
                        const refreshedTask = await database_1.TaskService.getTask(state.task.id, state.userId);
                        if (refreshedTask) {
                            newState.task = refreshedTask;
                        }
                    }
                    break;
                case types_1.ActionType.SearchTasks:
                    const searchResults = await database_1.TaskService.getTasks(state.userId, action.payload);
                    newState.tasks = searchResults;
                    break;
                case types_1.ActionType.UpdateManyTasks:
                    await database_1.TaskService.updateManyTasks(action.payload);
                    // Refresh tasks if we have them loaded
                    if (newState.tasks && newState.tasks.length > 0) {
                        newState.tasks = await database_1.TaskService.getTasks(state.userId);
                    }
                    break;
                case types_1.ActionType.LogActivity:
                    await database_1.LogService.createLog(Object.assign(Object.assign({}, action.payload), { userId: state.userId, author: 'Model' }));
                    break;
                case types_1.ActionType.ScheduleReminder:
                    if ((_c = state.task) === null || _c === void 0 ? void 0 : _c.id) {
                        await database_1.TaskService.updateTask({
                            id: state.task.id,
                            userId: state.userId,
                            notifications: {
                                create: [action.payload]
                            }
                        });
                    }
                    break;
                case types_1.ActionType.ProvideMotivation:
                case types_1.ActionType.GiveAdvice:
                case types_1.ActionType.AskQuestion:
                    // These are handled by adding messages to the state
                    // The action payload may contain the message content
                    if (action.payload.content) {
                        newState.messages.push(new messages_1.AIMessage({
                            content: action.payload.content,
                            name: action.type,
                        }));
                        // Also store in database if needed
                        await database_1.ChatMessageService.createMessage({
                            userId: state.userId,
                            taskId: (_d = state.task) === null || _d === void 0 ? void 0 : _d.id,
                            content: action.payload.content,
                            role: 'assistant',
                            metadata: { actionType: action.type }
                        });
                    }
                    break;
                default:
                    console.warn(`Unknown action type: ${action.type}`);
            }
        }
        catch (error) {
            console.error(`Error executing action ${action.type}:`, error);
            newState.error = `Failed to execute ${action.type}: ${error}`;
        }
    }
    return newState;
};
exports.executeActions = executeActions;
