import { ActionItem, ActionType, GraphState } from '../types';
import { TaskService, LogService, ChatMessageService } from '../services/database';

// Execute actions generated by the agents
export const executeActions = async (state: GraphState, actions: ActionItem[]): Promise<GraphState> => {
  const newState = { ...state };
  
  for (const action of actions) {
    try {
      switch (action.type) {
        case ActionType.CreateTask:
          const newTask = await TaskService.createTask({
            ...action.payload,
            userId: state.userId
          });
          newState.task = newTask;
          break;

        case ActionType.UpdateTask:
          if (state.task?.id) {
            const updatedTask = await TaskService.updateTask({
              id: state.task.id,
              userId: state.userId,
              ...action.payload
            });
            newState.task = updatedTask;
          }
          break;

        case ActionType.CreateSubtasks:
          if (state.task?.id) {
            await TaskService.createSubtasks(
              state.task.id,
              state.userId,
              action.payload.subtasks
            );

            // Refresh the task to include the new subtasks
            const refreshedTask = await TaskService.getTask(state.task.id, state.userId);
            if (refreshedTask) {
              newState.task = refreshedTask;
            }
          }
          break;

        case ActionType.SearchTasks:
          const searchResults = await TaskService.getTasks(state.userId, action.payload);
          newState.tasks = searchResults;
          break;

        case ActionType.UpdateManyTasks:
          await TaskService.updateManyTasks(action.payload);
          // Refresh tasks if we have them loaded
          if (newState.tasks && newState.tasks.length > 0) {
            newState.tasks = await TaskService.getTasks(state.userId);
          }
          break;

        case ActionType.LogActivity:
          await LogService.createLog({
            ...action.payload,
            userId: state.userId,
            author: 'Model'
          });
          break;

        case ActionType.ScheduleReminder:
          if (state.task?.id) {
            await TaskService.updateTask({
              id: state.task.id,
              userId: state.userId,
              notifications: {
                create: [action.payload]
              }
            });
          }
          break;

        case ActionType.ProvideMotivation:
        case ActionType.GiveAdvice:
        case ActionType.AskQuestion:
          // These are handled by adding messages to the state
          // The action payload may contain the message content
          if (action.payload.content) {
            newState.messages.push({
              role: 'assistant',
              content: action.payload.content,
              name: action.type,
            });

            // Also store in database if needed
            await ChatMessageService.createMessage({
              userId: state.userId,
              taskId: state.task?.id,
              content: action.payload.content,
              role: 'assistant',
              metadata: { actionType: action.type }
            });
          }
          break;

        default:
          console.warn(`Unknown action type: ${action.type}`);
      }
    } catch (error) {
      console.error(`Error executing action ${action.type}:`, error);
      newState.error = `Failed to execute ${action.type}: ${error}`;
    }
  }

  return newState;
};
